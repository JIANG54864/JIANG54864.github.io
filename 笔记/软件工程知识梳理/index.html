<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>软件工程知识梳理 | 姜将的个人博客</title><meta name="author" content="姜将"><meta name="copyright" content="姜将"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="第一章 软件工程概述1.1软件工程（SE）的定义、目的、方法、作用定义：在将有关软件开发与应用的概念科学体系化的基础上，研究如何有计划、有效率、经济的开发和利用能在计算机上正确运行的软件的理论和技术工程的方法学，以及一些开发和维护软件的方法、过程、原则。是一个系统工程，既有对技术问题的分析与综合，也有对开发过程和参与者的管理。 方法：面向对象模式，结构化模式，基于过程的模式等。 作用：付出较低的开">
<meta property="og:type" content="article">
<meta property="og:title" content="软件工程知识梳理">
<meta property="og:url" content="http://jiang54864.github.io/%E7%AC%94%E8%AE%B0/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/index.html">
<meta property="og:site_name" content="姜将的个人博客">
<meta property="og:description" content="第一章 软件工程概述1.1软件工程（SE）的定义、目的、方法、作用定义：在将有关软件开发与应用的概念科学体系化的基础上，研究如何有计划、有效率、经济的开发和利用能在计算机上正确运行的软件的理论和技术工程的方法学，以及一些开发和维护软件的方法、过程、原则。是一个系统工程，既有对技术问题的分析与综合，也有对开发过程和参与者的管理。 方法：面向对象模式，结构化模式，基于过程的模式等。 作用：付出较低的开">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pic1.imgdb.cn/item/6794d01ad0e0a243d4f7e064.jpg">
<meta property="article:published_time" content="2023-02-19T10:59:06.000Z">
<meta property="article:modified_time" content="2025-01-25T07:59:18.492Z">
<meta property="article:author" content="姜将">
<meta property="article:tag" content="软件工程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic1.imgdb.cn/item/6794d01ad0e0a243d4f7e064.jpg"><link rel="shortcut icon" href="https://pic1.imgdb.cn/item/6794d01ad0e0a243d4f7e064.jpg"><link rel="canonical" href="http://jiang54864.github.io/%E7%AC%94%E8%AE%B0/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '软件工程知识梳理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-01-25 15:59:18'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = 'hidden';
    document.getElementById('loading-box').classList.remove("loaded")
  }
}

preloader.initLoading()
window.addEventListener('load',()=> { preloader.endLoading() })

if (false) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://pic1.imgdb.cn/item/6794d01ad0e0a243d4f7e064.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">33</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/artitalk/"><i class="fa-fw fa fa-comment"></i><span> 说说</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="姜将的个人博客"><img class="site-icon" src="https://pic1.imgdb.cn/item/6794d01ad0e0a243d4f7e064.jpg"/><span class="site-name">姜将的个人博客</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/artitalk/"><i class="fa-fw fa fa-comment"></i><span> 说说</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">软件工程知识梳理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-02-19T10:59:06.000Z" title="发表于 2023-02-19 18:59:06">2023-02-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-01-25T07:59:18.492Z" title="更新于 2025-01-25 15:59:18">2025-01-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">14.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>42分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="软件工程知识梳理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="第一章-软件工程概述"><a href="#第一章-软件工程概述" class="headerlink" title="第一章 软件工程概述"></a>第一章 软件工程概述</h1><h2 id="1-1软件工程（SE）的定义、目的、方法、作用"><a href="#1-1软件工程（SE）的定义、目的、方法、作用" class="headerlink" title="1.1软件工程（SE）的定义、目的、方法、作用"></a>1.1软件工程（SE）的定义、目的、方法、作用</h2><p>定义：在将有关软件开发与应用的概念<strong>科学体系化的基础</strong>上，研究如何有计划、有效率、经济的开发和利用能在计算机上正确运行的软件的理论和技术工程的<strong>方法学</strong>，以及一些开发和维护软件的方法、过程、原则。是一个系统工程，既有对<strong>技术问题的分析与综合</strong>，也有对<strong>开发过程和参与者</strong>的管理。</p>
<p>方法：面向对象模式，结构化模式，基于过程的模式等。</p>
<p>作用：付出较低的开发成本，达到要求的软件功能，取得较好的软件性能，开发的软件易于移植，需要较低的维护费用，能按时完成开发工作，及时交付使用。</p>
<h2 id="1-2开发模式"><a href="#1-2开发模式" class="headerlink" title="1.2开发模式"></a>1.2开发模式</h2><p>软件开发的全部<strong>过程，活动和任务</strong>的<strong>结构框架</strong>，它能直观的表达软件开发全过程，明<br>确要完成的主要活动，任务和开发策略。</p>
<h2 id="1-3说明错误、缺陷和失败的含义及联系"><a href="#1-3说明错误、缺陷和失败的含义及联系" class="headerlink" title="1.3说明错误、缺陷和失败的含义及联系"></a>1.3说明错误、缺陷和失败的含义及联系</h2><p>错误(error)：是在软件<strong>开发过程</strong>中<strong>人为</strong>产生的错误（如：需求说明中的错误，代码中的错误）</p>
<p>缺陷（故障fault）：是在软件<strong>功能实现过程中</strong>产生的问题；是<strong>错误导致的结果</strong>，是在软件中一个错误的表现（如：代码写错了导致系统无法启动，一个错误可能产生多个缺陷，<strong>静态存在</strong>的）</p>
<p>失败(failure)：系统违背了它应有的行为（如：使用者发现某个计算功能算不出结果，是<strong>动态存在</strong>的）</p>
<p>联系：人为原因导致程序错误；该错误编译到系统中导致系统故障；用户使用该系统时，因故障导致失效。故障是系统内部视图，从开发者的角度看待问题；失效是系统外部视图， 从用户角度看到的问题。而且并不是所有的故障会导致失效，只要不执行故障代码，或者不进入某个特定状态，那么故障就不会使代码失效。</p>
<h2 id="1-4软件质量应从哪几个方面衡量"><a href="#1-4软件质量应从哪几个方面衡量" class="headerlink" title="1.4软件质量应从哪几个方面衡量"></a>1.4软件质量应从哪几个方面衡量</h2><p>1、产品(product)的质量</p>
<p>用户：从<strong>失效的数目和类型</strong>等外部特性进行评价，如果软件具有足够的功能，并且易于学习和使用；或者虽然难以学习和使用，但是由于功能值得这些付出，用户就断定软件是高质量的。</p>
<p>开发者：从<strong>故障的数目和类型</strong>等内部特征来作为产品质量的依据。</p>
<p>2、过程(process)的质量</p>
<p>有很多过程都会影响到最终的产品质量，只要有活动出了差错，产品的质量就会受到影响；开发和维护过程的质量与产品的质量是同等重要的。</p>
<p>3、商业(business)环境背景下的质量</p>
<p>(1) 技术价值与商业价值的联系与区别：</p>
<p>技术价值：技术指标（速度，正确的运行时间，维护成本等）。</p>
<p>商业价值：机构对软件是否与其战略利益相吻合的一种价值评估。</p>
<p>误区：技术质量不会自动转化为商业价值。</p>
<p>(2) 目标</p>
<p>将技术价值和商业价值统一起来，改进过程所带来的商业价值。</p>
<h2 id="1-5软件系统的系统组成（系统的要素有哪些）"><a href="#1-5软件系统的系统组成（系统的要素有哪些）" class="headerlink" title="1.5软件系统的系统组成（系统的要素有哪些）"></a>1.5软件系统的系统组成（系统的要素有哪些）</h2><p> 对象（实体）+ 活动 + 关系 + 系统边界</p>
<p>活动：活动是发生在系统中的某些事情，通常描述为由某个触发器引发的事件，活动通过改变属性把一个事物变成另一个事物。</p>
<p>对象：活动中涉及的元素称为对象。</p>
<p>关系：是指活动与对象之间的关系。</p>
<p>系统边界：即系统包含的功能与系统不包含的功能之间的界限。</p>
<h2 id="1-6现代软件工程大致包含几个阶段及各个阶段的文档"><a href="#1-6现代软件工程大致包含几个阶段及各个阶段的文档" class="headerlink" title="1.6现代软件工程大致包含几个阶段及各个阶段的文档"></a>1.6现代软件工程大致包含几个阶段及各个阶段的文档</h2><p>（1）需求分析：包括问题定义、可行性研究、需求分析【《SRS》即《软件需求规格 说明书》】与复审（所有人）。</p>
<p>（2）系统设计：包括用户界面的设计【《SAD》即《软件系统结构图》：如何制作软 件】与复审（开发者与客户）。</p>
<p>（3）程序设计：包括模块功能算法与数据描述设计【相关文档】与复审（开发者）。</p>
<p>（4）程序实现：包括编程与 debug【源代码和注释】与复审（开发者、码农）。</p>
<p>（5）单元测试：模块功能测试与性能测试【测试报告】与复审（测试团队）。</p>
<p>（6）集成测试：按照结构图进行测试【测试报告】与复审（测试团队）。</p>
<p>（7）系统测试：按《SRS》对系统总体功能进行测试与复审（开发者与客户）。</p>
<p>（8）系统提交：交付产品【用户手册和操作手册】与复审。</p>
<p>（9）系统维修：修改软件的过程，为改错或满足新需求【维修报告】与复审（维修团队）。</p>
<h2 id="1-7使现代软件工程实践发生变化的关键因素是什么？"><a href="#1-7使现代软件工程实践发生变化的关键因素是什么？" class="headerlink" title="1.7使现代软件工程实践发生变化的关键因素是什么？"></a>1.7使现代软件工程实践发生变化的关键因素是什么？</h2><p>（1）商用产品投入市场<strong>时间的紧迫性</strong></p>
<p>（2）计算技术在经济中的转变：<strong>更低的硬件成本，更高的开发、维护成本</strong></p>
<p>（3）功能强大的<strong>桌面计算</strong>的可用性</p>
<p>（4）广泛的<strong>局域网和广域网</strong></p>
<p>（5）<strong>面向对象技术</strong>的采用及其有效性</p>
<p>（6）使用窗口、图标、菜单和指示器的<strong>图形用户界面</strong></p>
<p>（7）软件开发<strong>瀑布模型的不可预测性</strong></p>
<h2 id="1-8什么是重用、抽象等现代软件工程主要概念？"><a href="#1-8什么是重用、抽象等现代软件工程主要概念？" class="headerlink" title="1.8什么是重用、抽象等现代软件工程主要概念？"></a>1.8什么是重用、抽象等现代软件工程主要概念？</h2><p>抽象(abstraction)：<strong>基于某种层次归纳水平的问题描述</strong>。它使我们将注意力集中在问题的关键方面而非细节。</p>
<p>分析、设计方法和符号描述系统：<strong>使用标准表示</strong>来对程序进行描述。利于交流，利于建模并检查其完整性和一致性，利于对需求和设计部件进行重用。</p>
<p>用户界面原型化(prototyping)：建立系统的小型版, 通常具有<strong>有限的关键功能</strong>,以利于用户<strong>评价和选择</strong>，证明设计或方法的可行性。</p>
<p>软件体系结构：定义一组<strong>体系结构单元及其相互关系集</strong>来描述软件系统。</p>
<p>软件过程：<strong>软件开发活动中的各种组织及规范方法</strong>。</p>
<p>重用或复用(reuse)：重复采用以前开发的软件系统中<strong>具有共性的部件</strong>, 用到新的开发项目中去 (注: 这里的重用绝不仅仅是源代码的重用)。</p>
<p>测度或度量(measurement)：通用的<strong>评价方法和体系</strong>，有助于使过程和产品的特定特性更加可见，包括量化描述系统、量化审核系统。</p>
<p>工具和集成环境：通过框架比较软件工程环境提供的服务，以决定其好坏。工具：由于厂商很少针对整个开发生命周期，因此对于工具的比较集中于小的活动集，例如测试或设计。</p>
<h1 id="第二章-过程与生命周期的建模"><a href="#第二章-过程与生命周期的建模" class="headerlink" title="第二章 过程与生命周期的建模"></a>第二章 过程与生命周期的建模</h1><h2 id="2-1什么叫过程，过程的重要性"><a href="#2-1什么叫过程，过程的重要性" class="headerlink" title="2.1什么叫过程，过程的重要性"></a>2.1什么叫过程，过程的重要性</h2><p>过程是<strong>一组有序的任务</strong>，它涉及活动、约束和资源使用的一系列步骤，用于产生某种想要的输出。</p>
<p>过程不仅仅是步骤，过程是步骤的集合，它将步骤组织起来使人们能够生产满足一系列目标和标准的产品。</p>
<p> （1）它强制活动具有<strong>一致性和一定的结构</strong>。</p>
<p>（2）过程结构允许我们<strong>分析、理解、控制和改进组成过程的活动</strong>，并以此来指导我们的活动。</p>
<p>（3）它使我们<strong>获取经验并把经验传授</strong>给他人。</p>
<h2 id="2-2什么是软件生命周期？"><a href="#2-2什么是软件生命周期？" class="headerlink" title="2.2什么是软件生命周期？"></a>2.2什么是软件生命周期？</h2><p>软件开发过程描述了软件产品从<strong>概念到实现、交付、使用和维护</strong>的整个过程，因此，有时把软件开发过程称为软件生命周期。</p>
<h2 id="2-3瀑布模型及各阶段文档，优缺点"><a href="#2-3瀑布模型及各阶段文档，优缺点" class="headerlink" title="2.3瀑布模型及各阶段文档，优缺点"></a>2.3瀑布模型及各阶段文档，优缺点</h2><p>瀑布模型：瀑布模型线性地安排每一个阶段，将开发阶段描述为从一个开发阶段瀑布般地转换到另外一个阶段，一个开发阶段必须在另一个开发阶段开始之前完成。瀑布模型从一种非常高层的角度描述了开发过程中进行的活动，并且提出了要求开发人员经过的时间序列。</p>
<p>瀑布模型的各阶段文档：</p>
<p>需求分析：《SRS》软件需求规格说明书</p>
<p>系统设计：《SAD》系统设计文档</p>
<p>程序设计：模块功能算法和数据描述文档</p>
<p>编码：源程序和注释</p>
<p>单元测试和集成测试：单元测试报告</p>
<p>系统测试：系统测试报告</p>
<p>验收测试：验收测试报告</p>
<p>运行与维护：维护报告</p>
<p>优点：</p>
<p>（1）它的<strong>简单性</strong>使得开发人员很容易向不熟悉软件开发的客户作出<strong>解释</strong>。</p>
<p>（2）每一个过程活动都有与其相关联的<strong>里程碑和可交付产品</strong>，以便于项目经理<strong>评估项目进度</strong>。</p>
<p>（3）瀑布模型是最基础的模型，很多其他更复杂的模型实际上是在瀑布模型的基础上的润色，如加入反馈循环以及额外的活动。</p>
<p>缺点：</p>
<p>（2）软件是一个创造的过程, 不是一个制造的过程。<strong>软件变动</strong>时, 该模型无法处理实际过程中的<strong>重复开发问题</strong>。</p>
<p>（3）<strong>文档转换有困难</strong>。它说明了每一个活动的产品（例如，需求、设计或代码），但没有揭示一个活动如何把一种制品转化为另外一种制品（例如，从需求文档转化为设计文档）。</p>
<h2 id="2-4什么是原型？"><a href="#2-4什么是原型？" class="headerlink" title="2.4什么是原型？"></a>2.4什么是原型？</h2><p>原型是一种部分开发的产品，用来让用户和开发者共同研究，提出意见，为最终产品定型。 </p>
<h2 id="2-5论述分阶段（阶段化）开发模型的含义、其基本分类和特点（运行系统和开发系统的概念）"><a href="#2-5论述分阶段（阶段化）开发模型的含义、其基本分类和特点（运行系统和开发系统的概念）" class="headerlink" title="2.5论述分阶段（阶段化）开发模型的含义、其基本分类和特点（运行系统和开发系统的概念）"></a>2.5论述分阶段（阶段化）开发模型的含义、其基本分类和特点（运行系统和开发系统的概念）</h2><p>含义：<strong>系统被设计成部分提交, 每次用户只能得到部分功能, 而其他部分处于开发过程中</strong>。</p>
<p>cycle time(循环时间): 软件开发时整理需求文档时间与系统提交时间之差(P55)</p>
<p>production system(产品系统): 用户正在使用的版本</p>
<p>development system(开发系统): 准备代替现有产品系统的下一个版本</p>
<p>分类：</p>
<p>（1）增量开发：系统需求按照功能分成若干子系统，开始建造的版本是规模小的、部分功能的系统，后续版本添加包含新功能的子系统，最后版本是包含全部功能的子系统集。</p>
<p>（2）迭代开发：系统开始就提供了整体功能框架，后续版本陆续增强各个子系统，最后版本使各个子系统的功能达到最强。</p>
<p>（3）增量式+迭代式结合开发：一个新发布的版本可能包含新功能，并对已有功能做了改进。</p>
<p>特点：</p>
<p>（1）即使还缺少某些功能，但在早期的发布中就可以开始培训。</p>
<p>（2）可以及早为那些以前从未提供的功能开拓市场。</p>
<p>（3）当运行系统出现未预料到的问题时，经常性的发布可以使开发人员能全面、快速地修复这些问题</p>
<p>（4）针对不同的发布版本，开发团队将重点放在不同的专业领域技术上。</p>
<h2 id="2-6螺旋模型的含义、目的、四个象限的任务及四重迭代（四重循环）的含义"><a href="#2-6螺旋模型的含义、目的、四个象限的任务及四重迭代（四重循环）的含义" class="headerlink" title="2.6螺旋模型的含义、目的、四个象限的任务及四重迭代（四重循环）的含义"></a>2.6螺旋模型的含义、目的、四个象限的任务及四重迭代（四重循环）的含义</h2><p>//含义：螺旋模型将瀑布模型和快速原型模型结合起来，强调了其他模型所忽视的风险分析，特别适合于大型复杂的系统。</p>
<p>//目的：把开发活动和风险管理结合起来，以将风险减到最小并控制风险。</p>
<p>螺旋模型每次迭代有四个任务，依次是（四个象限）：<strong>计划、目标/可选方案、风险评估、开发与测试</strong>。</p>
<p>螺旋模型共有四次迭代，依次是（每个象限的四重循环），依次是<strong>操作概念、软件需求、软件设计、开发与测试</strong>。</p>
<p>每一次迭代都根据需求和约束进行风险分析，以权衡不同选择，并且在确定选择之前，通过原型化验证可行性和期望度。当风险确认之后，项目经理必须决定如何消除或最小化风险。</p>
<p>//——— 习题2， 3。</p>
<p>//在所有的软件开发模型中，你认为哪些过程给予你最大的灵活性以应对需求的变更？</p>
<p>①设计对于分析模型应该是可跟踪的：软件的模块可能被映射到多个需求上。<br>②设计结构应当尽可能的模拟实际问题。<br>③设计应当表现出一致性。<br>④不要把设计当成编写代码。<br>⑤在创建设计时就应该能够评估质量</p>
<h2 id="2-7什么是UP、-RUP、进化式迭代等市场流行的过程模型"><a href="#2-7什么是UP、-RUP、进化式迭代等市场流行的过程模型" class="headerlink" title="2.7什么是UP、 RUP、进化式迭代等市场流行的过程模型"></a>2.7什么是UP、 RUP、进化式迭代等市场流行的过程模型</h2><p>UP模型即统一过程模型，是一种<strong>用例驱动的，以基础架构为中心的，迭代式，增量式的</strong>软件开发模型。</p>
<p>该模型的四个阶段：开始阶段、确立阶段、构建阶段和移交阶段。每个阶段可以进一步划分为多次迭代。该模型的六道核心工序：业务模型工序、需求工序、分析设计工序、实现工序、测试工序和部署工序。</p>
<p>RUP（Rational Unified Process），是IBM提出的提供支持和包装的UP模型。统一软件开发过程，统一软件过程是一个面向对象且基于网络的程序开发方法论。</p>
<p>进化式迭代开发（Iterative development）是统一开发过程(RUP)的<strong>关键实践</strong>。开发被组织成一系列固定的短期小项目。每次迭代都产生经过测试、集成并可执行的局部系统。每次迭代都具有各自的需求分析、设计、实现和测试。随着时间和一次次迭代，系统增量式完善。</p>
<h1 id="第三章-计划和管理项目"><a href="#第三章-计划和管理项目" class="headerlink" title="第三章 计划和管理项目"></a>第三章 计划和管理项目</h1><h2 id="3-1什么是项目进度？活动？里程碑？项目成本？"><a href="#3-1什么是项目进度？活动？里程碑？项目成本？" class="headerlink" title="3.1什么是项目进度？活动？里程碑？项目成本？"></a>3.1什么是项目进度？活动？里程碑？项目成本？</h2><p>项目进度：是对<strong>特定项目的软件开发周期的刻画</strong>。包括对项目阶段、步骤、活动的分解，对各个离散活动的交互关系的描述，以及对各个活动完成时间及整个项目完成时间的初步估算。</p>
<p>活动：项目的一部分，一般占用项目进度计划中的一段时间</p>
<p>里程碑（Milestone）指特定的时间点，标志着活动的结束，通常伴随着提交物。（如一般性文档，功能模块的说明，子系统的说明和展示，精确度的说明和展示，可靠性，安全性，性能说明或展示文档）</p>
<p>项目成本(project costs)：为支持软件开发而购买软件和工具的开支,用于支持需求分析,设计,编码,测试,处理需求变更等等,另外加上工作量开支。</p>
<h2 id="3-2软件人员应该具备的能力是什么？"><a href="#3-2软件人员应该具备的能力是什么？" class="headerlink" title="3.2软件人员应该具备的能力是什么？"></a>3.2软件人员应该具备的能力是什么？</h2><p>（1）完成工作的能力（2）对工作的兴趣（3）开发类似应用的经验（4）使用类似工具或语言的经验（5）使用类似开发环境的经验（6）使用类似技术的经验（7）培训（8）与其他人交流的能力（9）与其他人共同承担责任的能力（10）管理技能</p>
<h2 id="3-3软件项目团队组织的基本结构"><a href="#3-3软件项目团队组织的基本结构" class="headerlink" title="3.3软件项目团队组织的基本结构"></a>3.3软件项目团队组织的基本结构</h2><p>(1) 主程序员负责制（Chief Programmer Team）</p>
<p>由一个主程序员负责系统设计和开发，其他的成员向其汇报，主程序员对每一个决定有绝对决策权。</p>
<p>优势：<strong>使交流最小化，迅速做出决定</strong></p>
<p>缺点：<strong>创造性低；对主程序员要求高，个人主观性强</strong></p>
<p>(2) 忘我方法（Egoless Approach）</p>
<p>每个成员平等的承担责任，而且过程与个人是分开的；批评是针对产品和结果的，不针对个人的。</p>
<p>一般软件项目的团队组织结构是介于以上两个极端之间的。</p>
<p>(3) 项目组织的结构化</p>
<p>结构化较强的团队：按时完成任务，单工作比较循规蹈矩，项目普通但是功能完备。适合人员较多，项目稳 定性和一致性高，使用较正规的结构。</p>
<p>结构化较弱的团队：不能按时完成任务但是创造性强，涉及大量的不确定性因素时采用较为民主的方法和相关的团队结构</p>
<h2 id="3-4试述COCOMO模型的三个阶段基本工作原理或含义"><a href="#3-4试述COCOMO模型的三个阶段基本工作原理或含义" class="headerlink" title="3.4试述COCOMO模型的三个阶段基本工作原理或含义"></a>3.4试述COCOMO模型的三个阶段基本工作原理或含义</h2><p>COCOMO 模型的关键在于针对项目开发的不同阶段来设置<strong>工作量的衡量标准</strong>，逐步细化， 逐渐准确。</p>
<p>在阶段一，项目通常<strong>构建原型以解决包含用户界面、软件和系统交互、性能和技术成熟性等方面在内的高风险问题</strong>。这时，人们对正在创建的最终产品可能的规模知之甚少，因此COCOMOⅡ用<strong>应用点</strong>来估算规模。    </p>
<p>在阶段二，即早期设计阶段，已经决定将项目开发向前推进，但是设计人员必须研究几种可选的<strong>体系结构和操作的概念</strong>。同样，仍然没有足够的信息支持准确的工作量和工期估算，但是远比第一阶段知道的信息要多。在阶段二，COCOMOⅡ使用<strong>功能点</strong>对规模进行测量。</p>
<p>在阶段三，即后体系结构阶段，开发已经开始，而且已经知道了更多的信息。在这个阶段，可以根据<strong>功能点或代码行</strong>来进行规模估算，而且可以较为轻松地估算很多成本因素。</p>
<h2 id="3-5什么是软件风险？-了解主要风险管理活动？有几种降低风险的策略？"><a href="#3-5什么是软件风险？-了解主要风险管理活动？有几种降低风险的策略？" class="headerlink" title="3.5什么是软件风险？ 了解主要风险管理活动？有几种降低风险的策略？"></a>3.5什么是软件风险？ 了解主要风险管理活动？有几种降低风险的策略？</h2><p>概念：软件生产过程中不希望看到的，有负面结果的事件。</p>
<p>方面：风险损失，风险概率（相乘为风险暴露Risk Exposure)，即数学期望）</p>
<p>风险管理活动：</p>
<p>风险评价：风险识别，风险分析，风险优先级分配</p>
<p>风险控制：风险降低，风险管理计划，风险化解。</p>
<p>降低风险的策略：</p>
<p><strong>避免</strong>风险（Avoiding the risk）：改变功能和性能需求，使风险没机会发生。比如用 C 语言的程序有内存泄漏的风险改用 Java，避免风险。</p>
<p><strong>转移</strong>风险（Transferring the risk）：通过把风险分配到其他系统中，或者购买保险以便在风险成为事实时弥补经济上的损失。</p>
<p><strong>假设</strong>风险（Assuming the risk）：用项目资源，接受并控制风险。比如在开发时主动有意识地进行测试。</p>
<h1 id="第四章-获取需求"><a href="#第四章-获取需求" class="headerlink" title="第四章 获取需求"></a>第四章 获取需求</h1><h2 id="4-1需求的含义是什么？"><a href="#4-1需求的含义是什么？" class="headerlink" title="4.1需求的含义是什么？"></a>4.1需求的含义是什么？</h2><p>需求：对来自用户的关于软件系统的<strong>期望行为的综合描述</strong>，涉及系统的对象、状态、约束、功能等。</p>
<h2 id="4-2确定需求的过程（获取需求的过程）是什么？"><a href="#4-2确定需求的过程（获取需求的过程）是什么？" class="headerlink" title="4.2确定需求的过程（获取需求的过程）是什么？"></a>4.2确定需求的过程（获取需求的过程）是什么？</h2><p>①原始需求获取：客户给出的需求</p>
<p>②问题分析：理解需求并通过建模或模型化方式进行描述</p>
<p>③<strong>规格说明草稿</strong>：利用符号描述系统将定义规范化表示</p>
<p>④需求核准：开发人员与客户进行核准</p>
<p>⑤<strong>软件规格说明</strong>（SRS）</p>
<h2 id="4-3举例说明获取需求时，若有冲突发生，如何考虑根据优先级进行需求分类？"><a href="#4-3举例说明获取需求时，若有冲突发生，如何考虑根据优先级进行需求分类？" class="headerlink" title="4.3举例说明获取需求时，若有冲突发生，如何考虑根据优先级进行需求分类？"></a>4.3举例说明获取需求时，若有冲突发生，如何考虑根据优先级进行需求分类？</h2><p>（1）必须要满足的需求</p>
<p>（2）非常值得做但是不是必须的需求</p>
<p>（3）可选的需求（可做可不做）</p>
<h2 id="4-4如何使需求变得可测试？"><a href="#4-4如何使需求变得可测试？" class="headerlink" title="4.4如何使需求变得可测试？"></a>4.4如何使需求变得可测试？</h2><p>①针对需求确定一种<strong>量化的描述</strong>方法，避免模糊的表达方式<br>②将各种指代用词替代为<strong>实体的正式名字</strong><br>③每个名词或事项应在需求文档中给出<strong>唯一定义</strong></p>
<h2 id="4-5需求文档分为哪两类？"><a href="#4-5需求文档分为哪两类？" class="headerlink" title="4.5需求文档分为哪两类？"></a>4.5需求文档分为哪两类？</h2><p>(1) 需求定义: 完整罗列了客户期望的需求</p>
<p>(2) 需求规格说明（SRS）: 将需求重述为关于要构建的系统将如何运转的规格说明。</p>
<h2 id="4-6什么是功能需求和非功能需求（质量需求）"><a href="#4-6什么是功能需求和非功能需求（质量需求）" class="headerlink" title="4.6什么是功能需求和非功能需求（质量需求）"></a>4.6什么是功能需求和非功能需求（质量需求）</h2><p>功能需求：描述系统<strong>内部功能</strong>或系统<strong>与外部功能的交互</strong>作用，涉及系统输入应对、实体状态变化、输出结果、设计约束、过程约束等。根据要求的活动来描述需求的行为。（功能需求定义问题解决方案空间的边界）</p>
<p>非功能需求（质量需求）：描述软件方案必须具备的某些<strong>质量特征</strong>，例如系统性能、安全性、快速的响应时间、易使用性、高可靠性或低维护代价等。</p>
<h2 id="4-7列出类图中各个类间的基本关系"><a href="#4-7列出类图中各个类间的基本关系" class="headerlink" title="4.7列出类图中各个类间的基本关系"></a>4.7列出类图中各个类间的基本关系</h2><p>泛化：继承关系，用带三角的实线表示<br>实现：类和接口的关系，用带三角虚线表示<br>关联：拥有的关系，一个类知道另一个类的属性和方法，如老师和学生，用带普通箭头的实<br>线表示，双向拥有则为直线<br>聚合：整体和部分的关系，部分可以离开整体独立存在，用带空心菱形的实线表示。<br>组合：整体和部分的关系，部分不能离开整体独立存在，用带实心菱形的实线表示</p>
<h2 id="4-8需求的特征"><a href="#4-8需求的特征" class="headerlink" title="4.8需求的特征"></a>4.8需求的特征</h2><p>（1）正确性（2）一致性（3）无二义性（确定性）（4）完备性（5）可行性（6）相关性（7）可测试性（8）可跟踪性</p>
<h2 id="4-9在原型化需求方面，什么是抛弃式原型，什么是进化式原型？"><a href="#4-9在原型化需求方面，什么是抛弃式原型，什么是进化式原型？" class="headerlink" title="4.9在原型化需求方面，什么是抛弃式原型，什么是进化式原型？"></a>4.9在原型化需求方面，什么是抛弃式原型，什么是进化式原型？</h2><p>原型化需求的目的：</p>
<p>A: 有的需求难以用文字和符号说明,而原型化的过程可帮助我们找到“好的视觉和感觉”</p>
<p>B：对非功能性需求，可以评价性能和效率</p>
<p>抛弃式原型：仅用于了解问题、探索可行性，并不打算用来作为将来实际提交系统的一部分，而是用完扔掉</p>
<p>进化式原型：用于了解问题，并作为将来准备提交的系统的一部分</p>
<p>这两种技术有时都称为快速原型化，因为它们都是为了回答需求的问题而构建软件。</p>
<h1 id="第五章-设计体系结构"><a href="#第五章-设计体系结构" class="headerlink" title="第五章 设计体系结构"></a>第五章 设计体系结构</h1><h2 id="5-1什么是软件体系结构？设计模式？设计公约？设计？"><a href="#5-1什么是软件体系结构？设计模式？设计公约？设计？" class="headerlink" title="5.1什么是软件体系结构？设计模式？设计公约？设计？"></a>5.1什么是软件体系结构？设计模式？设计公约？设计？</h2><p>体系结构Architecture:一种<strong>软件解决方案</strong>，用于解释<strong>如何将系统分解为单元</strong>，以及单元如何相互<strong>关联</strong>，还包括这些单元的所有<strong>外部特性</strong>。</p>
<p>设计模式design pattern：一种针对<strong>单个软件模块或少量模块</strong>而给出的一般性<strong>解决方案</strong>，它提供较低层次的设计决策。它是一个共同的设计结构的关键方面，包括对象和实例，角色和协作，责任分配。</p>
<p>设计公约Design Convention:一系列<strong>设计决策和建议</strong>的集合，用于提高系统某方面的设计质量。当一种设计公约发展成熟时，将会被<strong>封装成设计模式或体系结构风格</strong>，最后可能被内嵌为一种程序语言结构。    </p>
<p>设计Design:将需求中的问题描述转变成软件解决方案的创造性过程。</p>
<h2 id="5-2软件过程中复审的概念，设计复审的重要性"><a href="#5-2软件过程中复审的概念，设计复审的重要性" class="headerlink" title="5.2软件过程中复审的概念，设计复审的重要性"></a>5.2软件过程中复审的概念，设计复审的重要性</h2><p>复审定义：检查文档是否满足所有功能及质量需求。</p>
<p>两种设计检验的方法：</p>
<p>(1) 验证verification：确保设计遵循良好的设计原则，设计文档满足阅读者的需要。验证检查某样东西是否符合之前已定好的标准，就是要用数据证明我们是不是在正确的制造产品。更注重过程正确性，强调做得正确</p>
<p>(2)确认validation：确认设计能够满足用户需求。确认检查软件在最终的运行环境上是否达到预期的目标，就是要用数据证明我们是不是制造了正确的产品。更注重结果正确 性，强调做的东西正确。</p>
<p>(3)验证更多是从开发商角度来做评审、测试来验证产品需求、架构设计等方面是否和用户要求一致，确认更多是从用户的角度或者可以是模拟用户角度来验证产品是否和自己想 要的一致。</p>
<p>重要性：</p>
<p>(1) 复审中批评和讨论是“忘我”的，能将开发人员更好地团结在一起，提倡并增强了成员之间的交流。</p>
<p>(2) 在评审过程中故障的改正还比较容易，成本还不高，在这时候发现故障和问题会使每一个人受益。</p>
<p>重要性：</p>
<p>1、可以和用户一起检查软件的概要设计。</p>
<p>2、可以向开发者呈现并明确软件的技术设计。</p>
<p>3、程序员通过复审可以在下一阶段的工程实施前得到本阶段工作的反馈。 </p>
<h2 id="5-3软件设计过程模型的几个阶段"><a href="#5-3软件设计过程模型的几个阶段" class="headerlink" title="5.3软件设计过程模型的几个阶段"></a>5.3软件设计过程模型的几个阶段</h2><p>(1) Modeling 初始建模:尝试可能的分解，根据需求描述的系统的关键特性等确定软件体系结构风格</p>
<p>(2) Analysis 分析:分析初步的体系结构，主要关注软件系统的质量属性性能、安全性、可靠性等、各种约束等等。关注系统级别决策</p>
<p>(3) Documentation 文档化:确定各个不同的模型视图。</p>
<p>(4) Review 复审:检查文档是否满足了所有需求。</p>
<p>(5) final output输出文档: SAD:Software Architecture Document 软件体系结构文档， 用来和开发团队中其他人员交流系统级别设计决策的有力工具。</p>
<h2 id="5-4三种设计层及其关系"><a href="#5-4三种设计层及其关系" class="headerlink" title="5.4三种设计层及其关系"></a>5.4三种设计层及其关系</h2><p>设计分三层：体系结构、代码设计和可执行设计</p>
<p>（1）体系结构将需求格式说明中确定的系统能力与实现这些能力的系统构件关联起来。</p>
<p>（2）代码设计包含算法和数据结构</p>
<p>（3）可执行设计在比代码设计的层次还要低的静态层次处理代码设计，讨论内存分配、数据格式、位模式等</p>
<p>自顶向下设计：首先设计体系结构，然后进行代码设计，最后是可执行设计</p>
<h2 id="5-5什么是模块化？什么是抽象？"><a href="#5-5什么是模块化？什么是抽象？" class="headerlink" title="5.5什么是模块化？什么是抽象？"></a>5.5什么是模块化？什么是抽象？</h2><p>模块化：在模块化的设计中，构件清晰地定义了输入和输出，设计目标明确，功能独立，可以做独立测试。</p>
<p>抽象：对细节的隐藏称为抽象，是基于某种归纳水平的问题描述，是我们集中于问题的关系。</p>
<h2 id="5-6论述设计用户界面应考虑的问题"><a href="#5-6论述设计用户界面应考虑的问题" class="headerlink" title="5.6论述设计用户界面应考虑的问题"></a>5.6论述设计用户界面应考虑的问题</h2><p>(1)设计界面要注意解决的要素：</p>
<p>①隐喻：可识别和学习的基本术语、图像和概念等</p>
<p>②思维模型：数据、功能、任务的组织与表示</p>
<p>③模型的导航规则：怎样在数据、功能、活动和角色中移动及切换</p>
<p>④外观：系统向用户传输信息的外观特征</p>
<p>⑤感觉：向用户提供有吸引力的体验的交互技术</p>
<p>(2) 文化问题：需要考虑使用系统的用户的信仰、价值观、道德规范、传统、风俗和传说。两种解决方法：</p>
<p>①使用<strong>国际设计/无偏见设计</strong>，排除特定的文化参考或偏见</p>
<p>②采用<strong>定制</strong>界面，使不同用户看到额界面</p>
<p>(3) 用户偏爱：为具有不同偏好的人选择备选界面</p>
<h2 id="5-7-耦合与内聚的概念及各个层次划分？"><a href="#5-7-耦合与内聚的概念及各个层次划分？" class="headerlink" title="5.7 耦合与内聚的概念及各个层次划分？"></a>5.7 耦合与内聚的概念及各个层次划分？</h2><p>模块的独立性取决于两个部分：内聚和耦合，我们追求的是高内聚低耦合。</p>
<p>内聚是软件内部组成成分的关联程度。</p>
<p>耦合指的是两个软件间的关联程度。</p>
<p>耦合的概念，如何分类？</p>
<p>耦合度是指两个软件之间的相互关联程度，耦合程度取决于模块之间的依赖关系的多少，可以划分为紧密耦合、松散耦合和非耦合。模块之间的依赖关系有：一个模块引用另一个模块、模块间传递数据量、某个模块控制其他模块的数量。为了使模块可以独立设计和修改，应尽可能减少耦合度。模块耦合有六个级别，从高到底依次为：</p>
<p>(1) 内容耦合 content：一个模块实际上修改了另一个模块，被修改的模块完全依赖于修改他的模块。可能的情况有：一个模块修改另一个模块内部数据项或代码，或分支转移 到另一个模块。如 goto 语句</p>
<p>(2) 公共耦合 common：不同模块可以从公共数据存储区来访问和修改数据。</p>
<p>(3) 控制耦合 control：一个模块通过传递参数或返回代码来控制另一个模块的活动</p>
<p>(4) 标记/特征耦合 stamp：使用一个复杂的数据结构进行模块间传递消息，并且传递的是该数据结构本身。比如将一个数组传递给另一个模块，数组仅用于计算而非控制</p>
<p>(5) 数据耦合 data：模块间传递的是数据值，这是最受欢迎的一种耦合。如一个数值被当做参数传递给另一个模块，这个数值在另一个模块中只会参与计算而非控制。</p>
<p>(6) 非耦合 uncoupled：模块相互之间没有信息传递，如两个毫无关系的方法，但是一般完全没有耦合是不现实的。</p>
<p>内聚的概念，如何分类？</p>
<p>内聚度是指模块内部各组成成分（如数据、功能、内部模块）的关联程度，内聚度越高， 模块各成分间相互联系越密切，与总目标越相关。内聚分为低内聚和高内聚。</p>
<p>(1) 偶然内聚 coincidental：模块各部分不相关，只为方便或偶然性原因放入同一模块。比如强行放入一个类中没有任何关系的方法</p>
<p>(2) 逻辑内聚 logical：模块中各部分只通过代码的逻辑结构相关联， 会共享程序状态和代码结构，但相对于数据、功能和目标的内聚比较弱。比如因为有相同的某一个计算步骤而放在 一起的两个没有关系的计算。</p>
<p>(3) 时间内聚 temporal：部件各部分要求在同一时间完成或被同一任务使用而形成联系。比如初始化模块中需要完成变量赋值、打开某文件等工作。</p>
<p>(4) 过程内聚 procedurally：要求必须按照某个确定的顺序执行一系列功能，模块内功能组合在一起只是为了确保这个顺序。其与时间性内聚相比优点在于其功能总是涉及相关 活动和针对相关目标，如写数据-&gt;检查数据-&gt;操作数据这一过程</p>
<p>(5) 通讯内聚 communicational：各部分访问和操作同一数据集，如将来自于同一传感器的所有不相干数据取出这一模块</p>
<p>(6) 顺序内聚 sequential：各部分有输入输出关系，操作统一数据集，并且操作有顺序</p>
<p>(7) 功能内聚 functional：理想情况，各部分组成单一功能，且每个处理元素对功能都是必须的，每个元素执行且只执行设计功能，如一个简单的输出程序</p>
<p>(8) 信息内聚 information：功能内聚的基础上调整为数据抽象化和基于对象的设计</p>
<h1 id="第六章-面向对象"><a href="#第六章-面向对象" class="headerlink" title="第六章 面向对象"></a>第六章 面向对象</h1><h2 id="6-1什么是面向对象？"><a href="#6-1什么是面向对象？" class="headerlink" title="6.1什么是面向对象？"></a>6.1什么是面向对象？</h2><p>是一种软件开发方法，它将<strong>问题及其解决方法组织成一系列独立的对象</strong>，数据结构和动<br>作都被包括在其中。</p>
<h2 id="6-2了解OO-设计的基本原则"><a href="#6-2了解OO-设计的基本原则" class="headerlink" title="6.2了解OO 设计的基本原则"></a>6.2了解OO 设计的基本原则</h2><p>单一职责原则（SRP）、重用原则、开闭原则（OCP）、里氏替换原则（LSP）、</p>
<p>依赖倒置原则（DIP）、接口分隔原则（ISP）、迪米特法则</p>
<h2 id="6-3了解OO开发有何优势？"><a href="#6-3了解OO开发有何优势？" class="headerlink" title="6.3了解OO开发有何优势？"></a>6.3了解OO开发有何优势？</h2><p>（1）语言的一致性。采用相同的<strong>语义结构</strong>（类、对象、接口、属性、行为）描述问题和解决方案</p>
<p>（2）全开发过程的一致性：从需求分析和定义、高层设计、底层设计到编码和测试等，所有的过程都采用相同的语义结构。</p>
<h2 id="6-4OO开发过程有几个步骤？"><a href="#6-4OO开发过程有几个步骤？" class="headerlink" title="6.4OO开发过程有几个步骤？"></a>6.4OO开发过程有几个步骤？</h2><p>面向对象需求分析、面向对象高层设计、面向对象底层设计、面向对象编程、面向对象测试。 </p>
<h2 id="6-5面向对象有什么特征？"><a href="#6-5面向对象有什么特征？" class="headerlink" title="6.5面向对象有什么特征？"></a>6.5面向对象有什么特征？</h2><p>（1）标识（2）抽象（3）分类（4）封装（5）继承（6）多态（7）持久性 </p>
<h2 id="6-6面向对象设计模式"><a href="#6-6面向对象设计模式" class="headerlink" title="6.6面向对象设计模式"></a>6.6面向对象设计模式</h2><p>简单工厂模式。工厂方法模式。抽象工程模式。观察者模式。单例模式。桥梁模式。责任链模式。适配器模式。代理模式。策略模式。</p>
<h2 id="6-7接口的三种含义"><a href="#6-7接口的三种含义" class="headerlink" title="6.7接口的三种含义"></a>6.7接口的三种含义</h2><p>①程序设计阶段，需要详细说明对象之间起交互作用的接口的特征（操<br>作签名）②<strong>多态</strong>意义上的接口，这允许我们利用多态的优点（我们可以只针对基类写出一段<br>程序，但它可以适应于这个类的家族，因为编译器会自动找出合适的对象来执行操作）实现<br>多态性的手段又叫做动态绑定③<strong>多继承</strong>意义上的接口（java 通过实现多接口的形式实现多<br>继承）</p>
<h2 id="6-8OO-的基本设计方法和技巧"><a href="#6-8OO-的基本设计方法和技巧" class="headerlink" title="6.8OO 的基本设计方法和技巧"></a>6.8OO 的基本设计方法和技巧</h2><p>OO 设计是从类图开始的，在需求分析完成之后，我们通过正确分析各个类之间的关系设<br>计类图（可以通过改进之前制作的概念类图），要遵循 OO 设计原则，采用适当的 OO 设计模式</p>
<h1 id="第七章-编写程序"><a href="#第七章-编写程序" class="headerlink" title="第七章 编写程序"></a>第七章 编写程序</h1><h2 id="7-1为什么说编码工作纷繁复杂甚至令人气馁？"><a href="#7-1为什么说编码工作纷繁复杂甚至令人气馁？" class="headerlink" title="7.1为什么说编码工作纷繁复杂甚至令人气馁？"></a>7.1为什么说编码工作纷繁复杂甚至令人气馁？</h2><p>（1） <strong>设计人员</strong>可能没有处理平台和编程环境的所有特性，易于用图表示的结构和关系<br>并不是总能直截了当的编写代码。<br>（2） 编写<strong>易于理解</strong>的代码<br>（3） 编写的代码要<strong>易于重用</strong><br>（4） 需要比照着设计进行<strong>检查</strong></p>
<h2 id="7-2一般性的编程原则应该从哪三个方面考虑？"><a href="#7-2一般性的编程原则应该从哪三个方面考虑？" class="headerlink" title="7.2一般性的编程原则应该从哪三个方面考虑？"></a>7.2一般性的编程原则应该从哪三个方面考虑？</h2><p>（1）控制结构（程序如何传递数据）：当设计转变成代码时，我们希望保留组件的控制结构，在隐含调用的面向对象设计中，控制是基于系统状态和变量而变化的。</p>
<p>　（2）算法（程序如何处理数据）：在编写代码时，程序设计通常会制定一类算法，用于编写组件。</p>
<p>　（3）数据结构（程序如何储存数据）：编写程序时，应该安排数据的格式并进行存储，这样的数据管理和操作才能简明易懂。</p>
<h2 id="7-3论述编码阶段实现某种算法时说涉及的问题。"><a href="#7-3论述编码阶段实现某种算法时说涉及的问题。" class="headerlink" title="7.3论述编码阶段实现某种算法时说涉及的问题。"></a>7.3论述编码阶段实现某种算法时说涉及的问题。</h2><p>（1）<strong>编写</strong>更快代码的代价。可能会是代码更加复杂，从而要花费更多的时间编写代码</p>
<p>　（2）<strong>测试</strong>代码的时间代价。代码的复杂度要求有更多的测试用例或测试数据</p>
<p>　（3）用户<strong>理解</strong>代码的时间代价。</p>
<p>　（4）需要<strong>修改</strong>代码时，修改代码的时间代价。</p>
<h2 id="7-4在编程程序内部文档时，除了HCB外，还应添加什么注释信息？注意什么？"><a href="#7-4在编程程序内部文档时，除了HCB外，还应添加什么注释信息？注意什么？" class="headerlink" title="7.4在编程程序内部文档时，除了ＨＣＢ外，还应添加什么注释信息？注意什么？"></a>7.4在编程程序内部文档时，除了ＨＣＢ外，还应添加什么注释信息？注意什么？</h2><p>（1）解释性注释：本段源代码是在做什么的注释。</p>
<p>（2）分解性注释：通过注释将代码分解成多个段。</p>
<p>（3）版本注释：随着时间进行修改的记录。</p>
<p>注意的问题：</p>
<p>1、分段注释</p>
<p>2、注释和代码要一并更改。</p>
<p>3、注释要有意义。</p>
<p>4、一边写代码一边写注释，不要写完代码回过头来添加注释。</p>
<p>内部文档：</p>
<p>（1）头注释块（header comment block，HCB）</p>
<p>将一组注释信息放在每个构件的开始部分，包含构件名，作者，配置在整个系统设计的哪个部分上，何时编写和修改的，为什么要有该构件，构件是如何使用数据结构，算法和控制的。</p>
<p>（2）其他程序注释包含：</p>
<p>a. 可以对程序正在做什么提供逐行的解释。</p>
<p>b. 将代码分解成表示主要活动的段，每个活动再分解成更小的步骤。</p>
<p>c. 随着时间进行修改的记录。</p>
<p>（3）有意义的变量名和语句标记</p>
<p>命名时尽量用有意义的变量名进行命名</p>
<p>（4）安排格式以增强理解</p>
<p>注意缩进和间隔来反映基本的控制结构。</p>
<h2 id="7-5敏捷方法的大致思想？"><a href="#7-5敏捷方法的大致思想？" class="headerlink" title="7.5敏捷方法的大致思想？"></a>7.5敏捷方法的大致思想？</h2><p>含义：以人为核心、迭代、循序渐进。在敏捷开发中，软件项目的构建被切分成多个子项目，各个子项目的成果都经过测试，具备集成和可运行的特征。</p>
<p>敏捷宣言四条原则：<strong>个体和交互的价值胜过过程和工具（个人的卓越创意），可以工作的软件胜过面面俱到的文档（文档非软件），客户合作胜过合同谈判，响应变化胜过遵循计划</strong>。</p>
<p>上述四条原则反映了敏捷方法的软件过程倾向性</p>
<p>目标：<strong>通过尽可能早地、持续地交付有价值的软件使客户满意</strong>。</p>
<h2 id="7-6什么是极限编程（Extreme-Programming，XP）？"><a href="#7-6什么是极限编程（Extreme-Programming，XP）？" class="headerlink" title="7.6什么是极限编程（Extreme Programming，ＸＰ）？"></a>7.6什么是极限编程（Extreme Programming，ＸＰ）？</h2><p><strong>极限编程是敏捷过程的一种具体形式，提供敏捷方法最一般原则的指导方针。</strong></p>
<p>XP的支持者强调敏捷方法的4个特性（准则）：交流、简单性、勇气以及反馈。</p>
<p>交流是指客户与开发人员之间持续地交换看法；简单性激励开发人员选择最简单的设计或实现来处理客户的需要；勇气体现在今早地和经常交付功能的承诺；在软件开发过程中的各种活动中，都包含反馈循环。例如，程序员一起工作，针对实现设计的最佳方式，相互提供反馈；客户和程序员一起工作时，以完成计划的任务。</p>
<h2 id="7-7什么是派对编程-Pair-Programming-？"><a href="#7-7什么是派对编程-Pair-Programming-？" class="headerlink" title="7.7什么是派对编程(Pair Programming)？"></a>7.7什么是派对编程(Pair Programming)？</h2><p>结对编程属于主要的敏捷开发方法，开发方式是两个程序员共同开发程序，且角色分工明确：一个负责编写程序，另一个负责复审和测试，两个人定期交换角色。</p>
<p>优点：提高生产率和质量，但证据不充分，模棱两可</p>
<p>缺点：会抑制问题求解的基本步骤，扰乱对问题的关注</p>
<h1 id="第八章-测试程序"><a href="#第八章-测试程序" class="headerlink" title="第八章 测试程序"></a>第八章 测试程序</h1><h2 id="8-1-了解-产生软件缺陷的原因？"><a href="#8-1-了解-产生软件缺陷的原因？" class="headerlink" title="8.1.了解 产生软件缺陷的原因？"></a>8.1.了解 产生软件缺陷的原因？</h2><p>故障：由错误（error）引起的系统内在问题。</p>
<p>(1)<strong>软件本身</strong>，系统处理大量的状态，复杂的公式，活动，算法等；</p>
<p>(2)<strong>客户</strong>不清晰的需求；</p>
<p>(3)其他原因，如项目的<strong>规模</strong>，众多的参与者导致的复杂性。</p>
<h2 id="8-2将软件缺陷进行分类的理由"><a href="#8-2将软件缺陷进行分类的理由" class="headerlink" title="8.2将软件缺陷进行分类的理由"></a>8.2将软件缺陷进行分类的理由</h2><p>在编码完程序构件之后，我们通常对代码进行检查，以找出故障并立刻去除它们。当不存在明显的故障时，我们测试程序，通过创造一些条件，是代码不能像计划的那样做出反应，看一看能否发现更多的故障。因此，知道我们正在查找什么类型的故障是很重要的。</p>
<h2 id="8-3几种主要的故障类型"><a href="#8-3几种主要的故障类型" class="headerlink" title="8.3几种主要的故障类型"></a>8.3几种主要的故障类型</h2><p>(1)算法故障(algorithmic fault)：由于处理步骤中的某些错误，使得对于给定的输入，构件的算法或逻辑没有产生适当的输出。</p>
<p>(2)计算故障(computation fault)或精度故障(precision fault)：一个公式的实现是错误的，或者计算结果没有达到要求的精度。</p>
<p>(3)文档故障(documentation fault)：文档与程序实际做的事情不一致。</p>
<p>(4)压力故障(stress fault)或过载故障(overload fault)：对队列长度、缓冲区大小、表的维度等的使用超出了规定的能力。</p>
<p>(5)能力故障(capacity fault)或边界故障(boundary fault)：系统活动到达指定的极限时，系统性能会变得不可接受。</p>
<p>(6)时序性故障(timing fault)或协调故障(coordination fault)：几个同时执行或仔细定义顺序执行的进程之间细条不适当。</p>
<p>(7)吞吐量故障(throughput fault)或性能故障(performance fault)：系统不能以需求规定的速度执行。</p>
<p>(8)恢复性故障(recovery fault)：当系统失效时，不能表现得像设计人员希望的或客户要求的那样。</p>
<p>(9)硬件和系统软件故障(hardware and system software fault)：当提供的硬件或者系统软件实际上并没有按照文档中的操作条件或步骤运作时。</p>
<p>(10)标准和过程故障(standards and procesure fault)：代码没有遵循组织机构的标准和过程。</p>
<h2 id="8-4什么是正交缺陷分类？"><a href="#8-4什么是正交缺陷分类？" class="headerlink" title="8.4什么是正交缺陷分类？"></a>8.4什么是正交缺陷分类？</h2><p>定义：被分类的任何一项故障都只属于一个类别，则分类方案是正交的。如果一个故障 属于不止一个类，则失去了度量的意义。</p>
<h2 id="8-5测试的各个阶段及其任务？"><a href="#8-5测试的各个阶段及其任务？" class="headerlink" title="8.5测试的各个阶段及其任务？"></a>8.5测试的各个阶段及其任务？</h2><p>(1)模块测试(module testing)、构件测试(component testing)或单元测试(unit testing)：将每个程序构件与系统中的其他构件隔离，对其本身进行测试。</p>
<p>(2)集成测试(integration testing)：验证系统构件是否能够按照系统和程序设计规格说明中描述的那样共同工作的过程。</p>
<p>(3)功能测试(function test)：对系统进行评估，以确定集成的系统是否确实执行了需求规格说明中描述的功能，其结果是一个可运转的系统。</p>
<p>(4)性能测试(performance test)：测试系统的软硬件性能是否符合需求规格说明文档。其结果是一个确认的系统。</p>
<p>(5)验收测试(acceptance test)：确定系统是按照用户的期望运转的。</p>
<p>(6)安装测试(installation test)：确保系统在实际环境中按照应有的方式运转。</p>
<p>(7)系统测试(system test)：功能测试、性能测试、验收测试和安装测试统称为系统测试。</p>
<h2 id="8-6测试的态度问题（为什么要独立设置测试团队？）"><a href="#8-6测试的态度问题（为什么要独立设置测试团队？）" class="headerlink" title="8.6测试的态度问题（为什么要独立设置测试团队？）"></a>8.6测试的态度问题（为什么要独立设置测试团队？）</h2><p>为了从测试过程中排除个人情感，通常是用一个独立的测试小组来测试系统，这样就避免了故障的个人责任与可能多地发现故障的需要之间的冲突。</p>
<h2 id="8-7掌握测试的方法——黑盒、白盒的概念？"><a href="#8-7掌握测试的方法——黑盒、白盒的概念？" class="headerlink" title="8.7掌握测试的方法——黑盒、白盒的概念？"></a>8.7掌握测试的方法——黑盒、白盒的概念？</h2><p>黑盒 将测试的对象看作是一个不了解其内容的闭盒，我们的测试就是向闭盒提供输入的数据，并记录产生的输出。测试的目标是确保针对每一种输入，观察到的输出与预期的输出相匹配。</p>
<p>定义：测试人员在完全不了解程序内部的逻辑结构和内部特性的情况下，只依据程序的需求规格及设计说明，检查程序的功能是否符合它的功能说明。(备注：1、测试时应该考虑让被测模块完成一切应做的事情, 拒绝一切不应做的事情。2、黑盒测试的参考文档是系统需求、主要文档是系统设计和程序设计阶段文档。若是可重用部件，则是类似系统)</p>
<p>优点：黑盒测试免于受强加给测试对象内部结构和逻辑的约束。更偏向于功能性的测试。</p>
<p>缺点：黑盒法以 SRS 为依据，有一定的<strong>盲目性和不确定性</strong>，不可能揭示所有的错误。</p>
<p>没办法总是使用这种方式进行完备的测试。不容易找到具有代表性的测试用例证明所有情况 下功能都正确。</p>
<p>白盒：将测试对象看作一个白盒，然后根据测试对象的结构用不同的方式进行测试。例如，可以设计执行构件内所有语句或所有控制路径的测试用例。</p>
<p>定义：以测试对象的内部结构为基本依据，手工或自动的展开各种测试。</p>
<p>优点：可以测试一个模块的细节。</p>
<p>缺点：该法以模块内部逻辑为依据，当<strong>内部逻辑过于复杂</strong>时，则不能给出好的或合适的测试用例。有时候，对于大量递归、循环和分支的构件，想要测试完所有的分支也是不现实的。</p>
<p>实际测试中，没有必要把黑盒测试和白盒测试严格的区分开来。具体的测试方法的选择收到很多因素的影响。</p>
<h2 id="8-8什么是单元测试？"><a href="#8-8什么是单元测试？" class="headerlink" title="8.8什么是单元测试？"></a>8.8什么是单元测试？</h2><p>将每个程序构件与系统中的其他构件隔离，对其本身进行测试。</p>
<h2 id="8-9什么是走查和检查？"><a href="#8-9什么是走查和检查？" class="headerlink" title="8.9什么是走查和检查？"></a>8.9什么是走查和检查？</h2><p>走查：不正式的的代码评审。</p>
<p>检查：正式的代码评审，事先准备问题清单，依据清单比对代码和文档的一致性。</p>
<h2 id="8-10黑盒、白盒方法各自的分类？测试用例的设计和给出方法。"><a href="#8-10黑盒、白盒方法各自的分类？测试用例的设计和给出方法。" class="headerlink" title="8.10黑盒、白盒方法各自的分类？测试用例的设计和给出方法。"></a>8.10黑盒、白盒方法各自的分类？测试用例的设计和给出方法。</h2><p>黑盒、白盒方法的分类，各种覆盖方法等。（课件等）</p>
<p>黑盒测试方法：</p>
<p>1、等价分类法：将输入域划分为若干等价类。每一个测试用例都代表了一类与它等价 的其他例子。如果测试用例没有发现错误，那么对应的等价例子也不会发生错误。有效等价 类的测试用例尽量公用，以此来减少测试次数，无效等价类必须每类一个用例，以防止漏掉 可能发现的错误。</p>
<p>2、边界值分析法：在等价分类法中，代表一个类的测试数据可以在这个类的允许范围 内任意选择。但如果把测试值选在等价类的边界上，往住有更好的效果，这就是边界值分析 法的主要思想。</p>
<p>3、错误猜测法：猜测程序中哪些地方容易出错，并据此设计测试用例。更多的依赖于 测试人员的直觉和经验。</p>
<p>4、因果图法：适用于被测试程序有很多输入条件，程序的输出又依赖输入条件的各种 组合的情况。</p>
<p>白盒测试方法：</p>
<p>逻辑覆盖法</p>
<p>1、语句覆盖：程序的每条语句都要执行一次。</p>
<p>2、判定(分支)覆盖：程序的每个分支都要执行一次。</p>
<p>3、条件覆盖：要求判定中的每个条件均按照“真”、“假”两种结果至少执行一次。</p>
<p>4、条件组合覆盖：要求所有条件结果的组合都至少出现一次。(比如 A&amp;&amp;B，两个条件，那么就有四种条件的组合)</p>
<p>路径测试法</p>
<h2 id="8-12集成测试及其主要方法的分类？（驱动模块、桩模块的概念）"><a href="#8-12集成测试及其主要方法的分类？（驱动模块、桩模块的概念）" class="headerlink" title="8.12集成测试及其主要方法的分类？（驱动模块、桩模块的概念）"></a>8.12集成测试及其主要方法的分类？（驱动模块、桩模块的概念）</h2><p>构件驱动程序就是<strong>调用特定构件并向其传递测试用例</strong>的程序，即代替上级模块传递测试用例的程序。</p>
<p>桩(stub)：一种专用程序，用于模拟测试时缺少构件时的活动。桩<strong>应答调用序列，并传回输出数据</strong>，使测试能够正常的进行下去，即代替下级模块的仿真程序。</p>
<p>分类：</p>
<p>1、自底向上集成</p>
<p>含义：使用这种测试方法的时候，每一个处于系统层次中最底层的构件先被单独测试，接着测试的是那些调用了前面已测试构件的构件。反复采用这种方法，直到所有的构件测试完毕。</p>
<p>先测试系统最底层的模块，接着测试调用这些底层模块的模块，直到测试完毕。</p>
<p>2、自顶向下集成</p>
<p>含义：顶层构件通常是一个控制构件，是独立进行测试的。然后将被测构件调用的所有构件组合起来，作为一个更大的单元进行测试。重复这样的操作直到所有的构件都被测试。</p>
<p>先测试系统最上层的模块，接着测试顶层模块调用的下层模块，直到测试完毕。</p>
<p>3、一次性集成</p>
<p>先测试每一个模块，之后将所有模块一并集成。</p>
<p>先测试每一个构件，然后将所有的构件一次性的集成。只适用于小型系统。</p>
<p>4、三明治集成</p>
<p>将系统分成三层，目标层处于中间、目标层上有一层，目标层下有一层。在顶层采用自顶向下的方式集成，在较低层采用自底向上的方式集成，测试集中于目标层。</p>
<h2 id="8-13传统测试和OO测试有何不同？OO测试有何困难？"><a href="#8-13传统测试和OO测试有何不同？OO测试有何困难？" class="headerlink" title="8.13传统测试和OO测试有何不同？OO测试有何困难？"></a>8.13传统测试和OO测试有何不同？OO测试有何困难？</h2><p>(1)测试<strong>用例的充分性</strong>：对过程语言而言，当系统改变时，我们可以针对改变测试是否正确，并使用原有的测试用例来验证剩余的功能是否同原来一致。但是面向对象的测试中，我们可能需要编写不同的测试用例。</p>
<p>(2)面向对象趋向于小粒度，并且平常存在于构件内的复杂性常常转移到构件之间的接口上。这意味着，其单元测试较为容易，但是<strong>集成测试涉及面变得更加广泛</strong>。</p>
<p>(3)传统测试和面向对象的测试主要集中在：需求分析和验证、测试用例生成、源码分析和覆盖。</p>
<p>困难：</p>
<p>A: 需求验证缺乏工具支持。（很多时候依赖人工）</p>
<p>B: 测试工具生成的测试用例，处理OO模型中的对象和方法时，其针对性不强。（某些OO关系是测试工具本身搞不清楚其内在逻辑关系的）</p>
<p>C: 传统的测试方法（如环路复杂度等）在评价OO系统的规模和复杂性时，还不是很有效。</p>
<p>D: 对象的交互是OO系统复杂性的根源，传统的测试方法和根据作用有限。</p>
<h2 id="8-14测试计划涉及的几个步骤？"><a href="#8-14测试计划涉及的几个步骤？" class="headerlink" title="8.14测试计划涉及的几个步骤？"></a>8.14测试计划涉及的几个步骤？</h2><p>(1)制定测试目标</p>
<p>(2)设计测试计划</p>
<p>(3)编写测试用例</p>
<p>(4)测试测试用例</p>
<p>(5)执行测试</p>
<p>(6)评估测试结果</p>
<h1 id="第九章-测试系统"><a href="#第九章-测试系统" class="headerlink" title="第九章 测试系统"></a>第九章 测试系统</h1><h2 id="9-1系统测试的主要步骤及各自含义"><a href="#9-1系统测试的主要步骤及各自含义" class="headerlink" title="9.1系统测试的主要步骤及各自含义"></a>9.1系统测试的主要步骤及各自含义</h2><p>(1)功能测试——系统功能需求。根据SRS测试系统功能。</p>
<p>(2)性能测试——其他软件需求。根据SRS测试系统性能。</p>
<p>(3)验收测试——客户需求规格说明书。根据客户的需求定义，由客户和用户一起测试。</p>
<p>(4)安装测试——用户环境。在用户环境下进行测试。 </p>
<h2 id="9-2什么是回归测试？"><a href="#9-2什么是回归测试？" class="headerlink" title="9.2什么是回归测试？"></a>9.2什么是回归测试？</h2><p>回归测试是用于新的版本或者改进版本的一种测试，以验证与旧版本相比，软件是否仍然以同样的方式执行同样的功能。 </p>
<h2 id="9-3功能测试的含义极其作用？"><a href="#9-3功能测试的含义极其作用？" class="headerlink" title="9.3功能测试的含义极其作用？"></a>9.3功能测试的含义极其作用？</h2><p>含义：测试需求设计（SRS）中提出的功能性需求。</p>
<p>作用：有很高的故障检测概率（因为一项功能测试只面向一小组组件）。</p>
<h2 id="9-4功能测试的基本指导原则？"><a href="#9-4功能测试的基本指导原则？" class="headerlink" title="9.4功能测试的基本指导原则？"></a>9.4功能测试的基本指导原则？</h2><p>(1)高故障检测概率；</p>
<p>(2)使用独立于设计人员和程序员的测试小组；</p>
<p>(3)了解期望的动作和输出；</p>
<p>(4)既要测试合法输入，也要测试不合法输入；</p>
<p>(5)制定停止测试的标准；</p>
<p>(6)不能修改系统。</p>
<h2 id="9-5性能测试的含义与作用？"><a href="#9-5性能测试的含义与作用？" class="headerlink" title="9.5性能测试的含义与作用？"></a>9.5性能测试的含义与作用？</h2><p>性能测试与需求的质量有密切的关系，需求文档需要足够完备才能确保性能测试的成功进行。因此需求的质量通常可以反映在性能测试的容易度上。</p>
<p>含义：测试非功能性需求。</p>
<p>作用：确保系统的可靠性、可用性和可维护性。</p>
<p>性能测试由测试小组进行设计和执行并将结果提供给客户。</p>
<h2 id="9-6性能测试的主要分类？"><a href="#9-6性能测试的主要分类？" class="headerlink" title="9.6性能测试的主要分类？"></a>9.6性能测试的主要分类？</h2><p>压力测试/强度测试(短时间内加载极限负荷，验证系统能力)</p>
<p>容量测试/巨量数据测试(验证系统处理巨量数据的能力)</p>
<p>配置测试(构建测试用例对系统软硬件的各种配置(最小到最大)进行测试)</p>
<p>兼容性测试(测试接口等。如果它与其他系统交互时)</p>
<p>回归测试(如果这个系统要替代一个现有系统时需要进行此测试)</p>
<p>安全性测试：确保安全性需求得到满足。</p>
<p>计时测试：评估涉及对用户的响应时间和一个功能的执行时间的相关需求。</p>
<p>环境测试：考察系统在安装场所的执行能力。</p>
<p>质量测试：评估系统的可靠性、可维护性和可用性。</p>
<p>恢复测试：强调的是系统对出现故障或丢失数据、电源、设备或服务时的反应。</p>
<p>维护测试：为了帮助人们发现问题的根源提供诊断工具和过程的需要。</p>
<p>文档测试：确保已经编写了必需的文档。</p>
<p>人为因素测试：检查设计系统用户界面的需求。</p>
<h2 id="9-7-确认测试概念，确认测试分类？（基准测试和引导测试）"><a href="#9-7-确认测试概念，确认测试分类？（基准测试和引导测试）" class="headerlink" title="9.7.确认测试概念，确认测试分类？（基准测试和引导测试）"></a>9.7.确认测试概念，确认测试分类？（基准测试和引导测试）</h2><p>由用户检查软件系统是否满足了他们的需求的测试。</p>
<p>(1)基准测试</p>
<p>由用户准备典型测试用例，在实际安装后的系统运作并由用户对系统执行情况进行评估。</p>
<p>(2)引导测试(课件译)/试验性测试(课本译)</p>
<p>在假设系统已经永久安装的前提下执行系统。它依赖系统的日常工作进行测试，相对基准测试不是非常的正式与结构化。</p>
<h2 id="9-8-什么是alpha测试？β测试？"><a href="#9-8-什么是alpha测试？β测试？" class="headerlink" title="9.8.什么是alpha测试？β测试？"></a>9.8.什么是alpha测试？β测试？</h2><p>α测试：在向客户发布一个系统之前，先让来自自己组织机构或公司的用户来测试这个系统。在客户进行实际的试验性测试前，先自己组织团队（或者委托其他团队）测试这个系统。</p>
<p>β测试：客户实际进行测试。</p>
<h2 id="9-9-什么是安装测试？"><a href="#9-9-什么是安装测试？" class="headerlink" title="9.9.什么是安装测试？"></a>9.9.什么是安装测试？</h2><p>在用户的系统环境中安装软件并进行测试。以测试可能因为开发环境与用户环境的不同而导致的问题。</p>
<h2 id="9-10什么是系统配置？软件配置管理？-基线？"><a href="#9-10什么是系统配置？软件配置管理？-基线？" class="headerlink" title="9.10什么是系统配置？软件配置管理？ 基线？"></a>9.10什么是系统配置？软件配置管理？ 基线？</h2><p>系统配置：向特定客户交付的一组系统构件</p>
<p>软件配置管理：开发和测试不同的配置需要配置管理。配置管理控制不同系统配置之间的差别，将风险和错误减少到最低程度。</p>
<p>基线：是指软件文档和其他资料的集合，它们代表了产品在某一时间点的情况(以及其他参考点)。</p>
<h2 id="9-11-什么是可靠性、可用性和可维护性？"><a href="#9-11-什么是可靠性、可用性和可维护性？" class="headerlink" title="9.11 什么是可靠性、可用性和可维护性？"></a>9.11 什么是可靠性、可用性和可维护性？</h2><p>可靠性：指一个系统对于给定的时间间隔内、在给定的条件下无失效运作的概率。</p>
<p>可用性：指在给定的时间点上，一个系统能够按照规格说明正确运作的概率。</p>
<p>可维护性：在给定的使用条件下，在规定的时间间隔内，使用规定的过程和资源完成维护活动的概率。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://jiang54864.github.io">姜将</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://jiang54864.github.io/%E7%AC%94%E8%AE%B0/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/">http://jiang54864.github.io/%E7%AC%94%E8%AE%B0/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://jiang54864.github.io" target="_blank">姜将的个人博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/">软件工程</a></div><div class="post_share"><div class="social-share" data-image="https://pic1.imgdb.cn/item/6794d01ad0e0a243d4f7e064.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/%E7%AC%94%E8%AE%B0/Linux%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/" title="Linux知识梳理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Linux知识梳理</div></div></a></div><div class="next-post pull-right"><a href="/%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/" title="计算机网络知识梳理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">计算机网络知识梳理</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://pic1.imgdb.cn/item/6794d01ad0e0a243d4f7e064.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">姜将</div><div class="author-info__description">记录学习中的知识与收获</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">33</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/JIANG54864"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=2792663690&amp;website=www.oicqzone.com" target="_blank" title="点击添加我的QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="https://www.helloimg.com/i/2025/01/25/6794f016e9b99.png" target="_blank" title="点击添加我的微信"><i class="fab fa-weixin"></i></a><a class="social-icon" href="mailto:jiangsw2022@163.com" target="_blank" title="给我发邮件"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客网站！若有需要，可通过上方联系方式找到我。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">第一章 软件工程概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%EF%BC%88SE%EF%BC%89%E7%9A%84%E5%AE%9A%E4%B9%89%E3%80%81%E7%9B%AE%E7%9A%84%E3%80%81%E6%96%B9%E6%B3%95%E3%80%81%E4%BD%9C%E7%94%A8"><span class="toc-number">1.1.</span> <span class="toc-text">1.1软件工程（SE）的定义、目的、方法、作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.2.</span> <span class="toc-text">1.2开发模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3%E8%AF%B4%E6%98%8E%E9%94%99%E8%AF%AF%E3%80%81%E7%BC%BA%E9%99%B7%E5%92%8C%E5%A4%B1%E8%B4%A5%E7%9A%84%E5%90%AB%E4%B9%89%E5%8F%8A%E8%81%94%E7%B3%BB"><span class="toc-number">1.3.</span> <span class="toc-text">1.3说明错误、缺陷和失败的含义及联系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E5%BA%94%E4%BB%8E%E5%93%AA%E5%87%A0%E4%B8%AA%E6%96%B9%E9%9D%A2%E8%A1%A1%E9%87%8F"><span class="toc-number">1.4.</span> <span class="toc-text">1.4软件质量应从哪几个方面衡量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%B3%BB%E7%BB%9F%E7%BB%84%E6%88%90%EF%BC%88%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%A6%81%E7%B4%A0%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%89"><span class="toc-number">1.5.</span> <span class="toc-text">1.5软件系统的系统组成（系统的要素有哪些）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6%E7%8E%B0%E4%BB%A3%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%A7%E8%87%B4%E5%8C%85%E5%90%AB%E5%87%A0%E4%B8%AA%E9%98%B6%E6%AE%B5%E5%8F%8A%E5%90%84%E4%B8%AA%E9%98%B6%E6%AE%B5%E7%9A%84%E6%96%87%E6%A1%A3"><span class="toc-number">1.6.</span> <span class="toc-text">1.6现代软件工程大致包含几个阶段及各个阶段的文档</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-7%E4%BD%BF%E7%8E%B0%E4%BB%A3%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5%E5%8F%91%E7%94%9F%E5%8F%98%E5%8C%96%E7%9A%84%E5%85%B3%E9%94%AE%E5%9B%A0%E7%B4%A0%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.7.</span> <span class="toc-text">1.7使现代软件工程实践发生变化的关键因素是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-8%E4%BB%80%E4%B9%88%E6%98%AF%E9%87%8D%E7%94%A8%E3%80%81%E6%8A%BD%E8%B1%A1%E7%AD%89%E7%8E%B0%E4%BB%A3%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%BB%E8%A6%81%E6%A6%82%E5%BF%B5%EF%BC%9F"><span class="toc-number">1.8.</span> <span class="toc-text">1.8什么是重用、抽象等现代软件工程主要概念？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%87%E7%A8%8B%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E5%BB%BA%E6%A8%A1"><span class="toc-number">2.</span> <span class="toc-text">第二章 过程与生命周期的建模</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1%E4%BB%80%E4%B9%88%E5%8F%AB%E8%BF%87%E7%A8%8B%EF%BC%8C%E8%BF%87%E7%A8%8B%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7"><span class="toc-number">2.1.</span> <span class="toc-text">2.1什么叫过程，过程的重要性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2%E4%BB%80%E4%B9%88%E6%98%AF%E8%BD%AF%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%9F"><span class="toc-number">2.2.</span> <span class="toc-text">2.2什么是软件生命周期？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3%E7%80%91%E5%B8%83%E6%A8%A1%E5%9E%8B%E5%8F%8A%E5%90%84%E9%98%B6%E6%AE%B5%E6%96%87%E6%A1%A3%EF%BC%8C%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">2.3.</span> <span class="toc-text">2.3瀑布模型及各阶段文档，优缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4%E4%BB%80%E4%B9%88%E6%98%AF%E5%8E%9F%E5%9E%8B%EF%BC%9F"><span class="toc-number">2.4.</span> <span class="toc-text">2.4什么是原型？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5%E8%AE%BA%E8%BF%B0%E5%88%86%E9%98%B6%E6%AE%B5%EF%BC%88%E9%98%B6%E6%AE%B5%E5%8C%96%EF%BC%89%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%90%AB%E4%B9%89%E3%80%81%E5%85%B6%E5%9F%BA%E6%9C%AC%E5%88%86%E7%B1%BB%E5%92%8C%E7%89%B9%E7%82%B9%EF%BC%88%E8%BF%90%E8%A1%8C%E7%B3%BB%E7%BB%9F%E5%92%8C%E5%BC%80%E5%8F%91%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A6%82%E5%BF%B5%EF%BC%89"><span class="toc-number">2.5.</span> <span class="toc-text">2.5论述分阶段（阶段化）开发模型的含义、其基本分类和特点（运行系统和开发系统的概念）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6%E8%9E%BA%E6%97%8B%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%90%AB%E4%B9%89%E3%80%81%E7%9B%AE%E7%9A%84%E3%80%81%E5%9B%9B%E4%B8%AA%E8%B1%A1%E9%99%90%E7%9A%84%E4%BB%BB%E5%8A%A1%E5%8F%8A%E5%9B%9B%E9%87%8D%E8%BF%AD%E4%BB%A3%EF%BC%88%E5%9B%9B%E9%87%8D%E5%BE%AA%E7%8E%AF%EF%BC%89%E7%9A%84%E5%90%AB%E4%B9%89"><span class="toc-number">2.6.</span> <span class="toc-text">2.6螺旋模型的含义、目的、四个象限的任务及四重迭代（四重循环）的含义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-7%E4%BB%80%E4%B9%88%E6%98%AFUP%E3%80%81-RUP%E3%80%81%E8%BF%9B%E5%8C%96%E5%BC%8F%E8%BF%AD%E4%BB%A3%E7%AD%89%E5%B8%82%E5%9C%BA%E6%B5%81%E8%A1%8C%E7%9A%84%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.7.</span> <span class="toc-text">2.7什么是UP、 RUP、进化式迭代等市场流行的过程模型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E8%AE%A1%E5%88%92%E5%92%8C%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE"><span class="toc-number">3.</span> <span class="toc-text">第三章 计划和管理项目</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1%E4%BB%80%E4%B9%88%E6%98%AF%E9%A1%B9%E7%9B%AE%E8%BF%9B%E5%BA%A6%EF%BC%9F%E6%B4%BB%E5%8A%A8%EF%BC%9F%E9%87%8C%E7%A8%8B%E7%A2%91%EF%BC%9F%E9%A1%B9%E7%9B%AE%E6%88%90%E6%9C%AC%EF%BC%9F"><span class="toc-number">3.1.</span> <span class="toc-text">3.1什么是项目进度？活动？里程碑？项目成本？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2%E8%BD%AF%E4%BB%B6%E4%BA%BA%E5%91%98%E5%BA%94%E8%AF%A5%E5%85%B7%E5%A4%87%E7%9A%84%E8%83%BD%E5%8A%9B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.2.</span> <span class="toc-text">3.2软件人员应该具备的能力是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E5%9B%A2%E9%98%9F%E7%BB%84%E7%BB%87%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-number">3.3.</span> <span class="toc-text">3.3软件项目团队组织的基本结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4%E8%AF%95%E8%BF%B0COCOMO%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%B8%89%E4%B8%AA%E9%98%B6%E6%AE%B5%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E6%88%96%E5%90%AB%E4%B9%89"><span class="toc-number">3.4.</span> <span class="toc-text">3.4试述COCOMO模型的三个阶段基本工作原理或含义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5%E4%BB%80%E4%B9%88%E6%98%AF%E8%BD%AF%E4%BB%B6%E9%A3%8E%E9%99%A9%EF%BC%9F-%E4%BA%86%E8%A7%A3%E4%B8%BB%E8%A6%81%E9%A3%8E%E9%99%A9%E7%AE%A1%E7%90%86%E6%B4%BB%E5%8A%A8%EF%BC%9F%E6%9C%89%E5%87%A0%E7%A7%8D%E9%99%8D%E4%BD%8E%E9%A3%8E%E9%99%A9%E7%9A%84%E7%AD%96%E7%95%A5%EF%BC%9F"><span class="toc-number">3.5.</span> <span class="toc-text">3.5什么是软件风险？ 了解主要风险管理活动？有几种降低风险的策略？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%8E%B7%E5%8F%96%E9%9C%80%E6%B1%82"><span class="toc-number">4.</span> <span class="toc-text">第四章 获取需求</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1%E9%9C%80%E6%B1%82%E7%9A%84%E5%90%AB%E4%B9%89%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">4.1.</span> <span class="toc-text">4.1需求的含义是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2%E7%A1%AE%E5%AE%9A%E9%9C%80%E6%B1%82%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%88%E8%8E%B7%E5%8F%96%E9%9C%80%E6%B1%82%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%89%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">4.2.</span> <span class="toc-text">4.2确定需求的过程（获取需求的过程）是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E%E8%8E%B7%E5%8F%96%E9%9C%80%E6%B1%82%E6%97%B6%EF%BC%8C%E8%8B%A5%E6%9C%89%E5%86%B2%E7%AA%81%E5%8F%91%E7%94%9F%EF%BC%8C%E5%A6%82%E4%BD%95%E8%80%83%E8%99%91%E6%A0%B9%E6%8D%AE%E4%BC%98%E5%85%88%E7%BA%A7%E8%BF%9B%E8%A1%8C%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%EF%BC%9F"><span class="toc-number">4.3.</span> <span class="toc-text">4.3举例说明获取需求时，若有冲突发生，如何考虑根据优先级进行需求分类？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4%E5%A6%82%E4%BD%95%E4%BD%BF%E9%9C%80%E6%B1%82%E5%8F%98%E5%BE%97%E5%8F%AF%E6%B5%8B%E8%AF%95%EF%BC%9F"><span class="toc-number">4.4.</span> <span class="toc-text">4.4如何使需求变得可测试？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5%E9%9C%80%E6%B1%82%E6%96%87%E6%A1%A3%E5%88%86%E4%B8%BA%E5%93%AA%E4%B8%A4%E7%B1%BB%EF%BC%9F"><span class="toc-number">4.5.</span> <span class="toc-text">4.5需求文档分为哪两类？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6%E4%BB%80%E4%B9%88%E6%98%AF%E5%8A%9F%E8%83%BD%E9%9C%80%E6%B1%82%E5%92%8C%E9%9D%9E%E5%8A%9F%E8%83%BD%E9%9C%80%E6%B1%82%EF%BC%88%E8%B4%A8%E9%87%8F%E9%9C%80%E6%B1%82%EF%BC%89"><span class="toc-number">4.6.</span> <span class="toc-text">4.6什么是功能需求和非功能需求（质量需求）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-7%E5%88%97%E5%87%BA%E7%B1%BB%E5%9B%BE%E4%B8%AD%E5%90%84%E4%B8%AA%E7%B1%BB%E9%97%B4%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%85%B3%E7%B3%BB"><span class="toc-number">4.7.</span> <span class="toc-text">4.7列出类图中各个类间的基本关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-8%E9%9C%80%E6%B1%82%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-number">4.8.</span> <span class="toc-text">4.8需求的特征</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-9%E5%9C%A8%E5%8E%9F%E5%9E%8B%E5%8C%96%E9%9C%80%E6%B1%82%E6%96%B9%E9%9D%A2%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E6%8A%9B%E5%BC%83%E5%BC%8F%E5%8E%9F%E5%9E%8B%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%9B%E5%8C%96%E5%BC%8F%E5%8E%9F%E5%9E%8B%EF%BC%9F"><span class="toc-number">4.9.</span> <span class="toc-text">4.9在原型化需求方面，什么是抛弃式原型，什么是进化式原型？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E8%AE%BE%E8%AE%A1%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">5.</span> <span class="toc-text">第五章 设计体系结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1%E4%BB%80%E4%B9%88%E6%98%AF%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%EF%BC%9F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9F%E8%AE%BE%E8%AE%A1%E5%85%AC%E7%BA%A6%EF%BC%9F%E8%AE%BE%E8%AE%A1%EF%BC%9F"><span class="toc-number">5.1.</span> <span class="toc-text">5.1什么是软件体系结构？设计模式？设计公约？设计？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%A4%8D%E5%AE%A1%E7%9A%84%E6%A6%82%E5%BF%B5%EF%BC%8C%E8%AE%BE%E8%AE%A1%E5%A4%8D%E5%AE%A1%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7"><span class="toc-number">5.2.</span> <span class="toc-text">5.2软件过程中复审的概念，设计复审的重要性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%87%A0%E4%B8%AA%E9%98%B6%E6%AE%B5"><span class="toc-number">5.3.</span> <span class="toc-text">5.3软件设计过程模型的几个阶段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4%E4%B8%89%E7%A7%8D%E8%AE%BE%E8%AE%A1%E5%B1%82%E5%8F%8A%E5%85%B6%E5%85%B3%E7%B3%BB"><span class="toc-number">5.4.</span> <span class="toc-text">5.4三种设计层及其关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5%E4%BB%80%E4%B9%88%E6%98%AF%E6%A8%A1%E5%9D%97%E5%8C%96%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E6%8A%BD%E8%B1%A1%EF%BC%9F"><span class="toc-number">5.5.</span> <span class="toc-text">5.5什么是模块化？什么是抽象？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-6%E8%AE%BA%E8%BF%B0%E8%AE%BE%E8%AE%A1%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E5%BA%94%E8%80%83%E8%99%91%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">5.6.</span> <span class="toc-text">5.6论述设计用户界面应考虑的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-7-%E8%80%A6%E5%90%88%E4%B8%8E%E5%86%85%E8%81%9A%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%90%84%E4%B8%AA%E5%B1%82%E6%AC%A1%E5%88%92%E5%88%86%EF%BC%9F"><span class="toc-number">5.7.</span> <span class="toc-text">5.7 耦合与内聚的概念及各个层次划分？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">6.</span> <span class="toc-text">第六章 面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="toc-number">6.1.</span> <span class="toc-text">6.1什么是面向对象？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2%E4%BA%86%E8%A7%A3OO-%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99"><span class="toc-number">6.2.</span> <span class="toc-text">6.2了解OO 设计的基本原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3%E4%BA%86%E8%A7%A3OO%E5%BC%80%E5%8F%91%E6%9C%89%E4%BD%95%E4%BC%98%E5%8A%BF%EF%BC%9F"><span class="toc-number">6.3.</span> <span class="toc-text">6.3了解OO开发有何优势？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4OO%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E6%9C%89%E5%87%A0%E4%B8%AA%E6%AD%A5%E9%AA%A4%EF%BC%9F"><span class="toc-number">6.4.</span> <span class="toc-text">6.4OO开发过程有几个步骤？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-5%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E5%BE%81%EF%BC%9F"><span class="toc-number">6.5.</span> <span class="toc-text">6.5面向对象有什么特征？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-6%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.6.</span> <span class="toc-text">6.6面向对象设计模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-7%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%B8%89%E7%A7%8D%E5%90%AB%E4%B9%89"><span class="toc-number">6.7.</span> <span class="toc-text">6.7接口的三种含义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-8OO-%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95%E5%92%8C%E6%8A%80%E5%B7%A7"><span class="toc-number">6.8.</span> <span class="toc-text">6.8OO 的基本设计方法和技巧</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E7%BC%96%E5%86%99%E7%A8%8B%E5%BA%8F"><span class="toc-number">7.</span> <span class="toc-text">第七章 编写程序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4%E7%BC%96%E7%A0%81%E5%B7%A5%E4%BD%9C%E7%BA%B7%E7%B9%81%E5%A4%8D%E6%9D%82%E7%94%9A%E8%87%B3%E4%BB%A4%E4%BA%BA%E6%B0%94%E9%A6%81%EF%BC%9F"><span class="toc-number">7.1.</span> <span class="toc-text">7.1为什么说编码工作纷繁复杂甚至令人气馁？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2%E4%B8%80%E8%88%AC%E6%80%A7%E7%9A%84%E7%BC%96%E7%A8%8B%E5%8E%9F%E5%88%99%E5%BA%94%E8%AF%A5%E4%BB%8E%E5%93%AA%E4%B8%89%E4%B8%AA%E6%96%B9%E9%9D%A2%E8%80%83%E8%99%91%EF%BC%9F"><span class="toc-number">7.2.</span> <span class="toc-text">7.2一般性的编程原则应该从哪三个方面考虑？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3%E8%AE%BA%E8%BF%B0%E7%BC%96%E7%A0%81%E9%98%B6%E6%AE%B5%E5%AE%9E%E7%8E%B0%E6%9F%90%E7%A7%8D%E7%AE%97%E6%B3%95%E6%97%B6%E8%AF%B4%E6%B6%89%E5%8F%8A%E7%9A%84%E9%97%AE%E9%A2%98%E3%80%82"><span class="toc-number">7.3.</span> <span class="toc-text">7.3论述编码阶段实现某种算法时说涉及的问题。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4%E5%9C%A8%E7%BC%96%E7%A8%8B%E7%A8%8B%E5%BA%8F%E5%86%85%E9%83%A8%E6%96%87%E6%A1%A3%E6%97%B6%EF%BC%8C%E9%99%A4%E4%BA%86HCB%E5%A4%96%EF%BC%8C%E8%BF%98%E5%BA%94%E6%B7%BB%E5%8A%A0%E4%BB%80%E4%B9%88%E6%B3%A8%E9%87%8A%E4%BF%A1%E6%81%AF%EF%BC%9F%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">7.4.</span> <span class="toc-text">7.4在编程程序内部文档时，除了ＨＣＢ外，还应添加什么注释信息？注意什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-5%E6%95%8F%E6%8D%B7%E6%96%B9%E6%B3%95%E7%9A%84%E5%A4%A7%E8%87%B4%E6%80%9D%E6%83%B3%EF%BC%9F"><span class="toc-number">7.5.</span> <span class="toc-text">7.5敏捷方法的大致思想？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-6%E4%BB%80%E4%B9%88%E6%98%AF%E6%9E%81%E9%99%90%E7%BC%96%E7%A8%8B%EF%BC%88Extreme-Programming%EF%BC%8CXP%EF%BC%89%EF%BC%9F"><span class="toc-number">7.6.</span> <span class="toc-text">7.6什么是极限编程（Extreme Programming，ＸＰ）？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-7%E4%BB%80%E4%B9%88%E6%98%AF%E6%B4%BE%E5%AF%B9%E7%BC%96%E7%A8%8B-Pair-Programming-%EF%BC%9F"><span class="toc-number">7.7.</span> <span class="toc-text">7.7什么是派对编程(Pair Programming)？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%B5%8B%E8%AF%95%E7%A8%8B%E5%BA%8F"><span class="toc-number">8.</span> <span class="toc-text">第八章 测试程序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-%E4%BA%86%E8%A7%A3-%E4%BA%A7%E7%94%9F%E8%BD%AF%E4%BB%B6%E7%BC%BA%E9%99%B7%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%9F"><span class="toc-number">8.1.</span> <span class="toc-text">8.1.了解 产生软件缺陷的原因？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2%E5%B0%86%E8%BD%AF%E4%BB%B6%E7%BC%BA%E9%99%B7%E8%BF%9B%E8%A1%8C%E5%88%86%E7%B1%BB%E7%9A%84%E7%90%86%E7%94%B1"><span class="toc-number">8.2.</span> <span class="toc-text">8.2将软件缺陷进行分类的理由</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-3%E5%87%A0%E7%A7%8D%E4%B8%BB%E8%A6%81%E7%9A%84%E6%95%85%E9%9A%9C%E7%B1%BB%E5%9E%8B"><span class="toc-number">8.3.</span> <span class="toc-text">8.3几种主要的故障类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-4%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%A3%E4%BA%A4%E7%BC%BA%E9%99%B7%E5%88%86%E7%B1%BB%EF%BC%9F"><span class="toc-number">8.4.</span> <span class="toc-text">8.4什么是正交缺陷分类？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-5%E6%B5%8B%E8%AF%95%E7%9A%84%E5%90%84%E4%B8%AA%E9%98%B6%E6%AE%B5%E5%8F%8A%E5%85%B6%E4%BB%BB%E5%8A%A1%EF%BC%9F"><span class="toc-number">8.5.</span> <span class="toc-text">8.5测试的各个阶段及其任务？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-6%E6%B5%8B%E8%AF%95%E7%9A%84%E6%80%81%E5%BA%A6%E9%97%AE%E9%A2%98%EF%BC%88%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%8B%AC%E7%AB%8B%E8%AE%BE%E7%BD%AE%E6%B5%8B%E8%AF%95%E5%9B%A2%E9%98%9F%EF%BC%9F%EF%BC%89"><span class="toc-number">8.6.</span> <span class="toc-text">8.6测试的态度问题（为什么要独立设置测试团队？）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-7%E6%8E%8C%E6%8F%A1%E6%B5%8B%E8%AF%95%E7%9A%84%E6%96%B9%E6%B3%95%E2%80%94%E2%80%94%E9%BB%91%E7%9B%92%E3%80%81%E7%99%BD%E7%9B%92%E7%9A%84%E6%A6%82%E5%BF%B5%EF%BC%9F"><span class="toc-number">8.7.</span> <span class="toc-text">8.7掌握测试的方法——黑盒、白盒的概念？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-8%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%9F"><span class="toc-number">8.8.</span> <span class="toc-text">8.8什么是单元测试？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-9%E4%BB%80%E4%B9%88%E6%98%AF%E8%B5%B0%E6%9F%A5%E5%92%8C%E6%A3%80%E6%9F%A5%EF%BC%9F"><span class="toc-number">8.9.</span> <span class="toc-text">8.9什么是走查和检查？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-10%E9%BB%91%E7%9B%92%E3%80%81%E7%99%BD%E7%9B%92%E6%96%B9%E6%B3%95%E5%90%84%E8%87%AA%E7%9A%84%E5%88%86%E7%B1%BB%EF%BC%9F%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%92%8C%E7%BB%99%E5%87%BA%E6%96%B9%E6%B3%95%E3%80%82"><span class="toc-number">8.10.</span> <span class="toc-text">8.10黑盒、白盒方法各自的分类？测试用例的设计和给出方法。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-12%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95%E5%8F%8A%E5%85%B6%E4%B8%BB%E8%A6%81%E6%96%B9%E6%B3%95%E7%9A%84%E5%88%86%E7%B1%BB%EF%BC%9F%EF%BC%88%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9D%97%E3%80%81%E6%A1%A9%E6%A8%A1%E5%9D%97%E7%9A%84%E6%A6%82%E5%BF%B5%EF%BC%89"><span class="toc-number">8.11.</span> <span class="toc-text">8.12集成测试及其主要方法的分类？（驱动模块、桩模块的概念）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-13%E4%BC%A0%E7%BB%9F%E6%B5%8B%E8%AF%95%E5%92%8COO%E6%B5%8B%E8%AF%95%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C%EF%BC%9FOO%E6%B5%8B%E8%AF%95%E6%9C%89%E4%BD%95%E5%9B%B0%E9%9A%BE%EF%BC%9F"><span class="toc-number">8.12.</span> <span class="toc-text">8.13传统测试和OO测试有何不同？OO测试有何困难？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-14%E6%B5%8B%E8%AF%95%E8%AE%A1%E5%88%92%E6%B6%89%E5%8F%8A%E7%9A%84%E5%87%A0%E4%B8%AA%E6%AD%A5%E9%AA%A4%EF%BC%9F"><span class="toc-number">8.13.</span> <span class="toc-text">8.14测试计划涉及的几个步骤？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E6%B5%8B%E8%AF%95%E7%B3%BB%E7%BB%9F"><span class="toc-number">9.</span> <span class="toc-text">第九章 测试系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1%E7%B3%BB%E7%BB%9F%E6%B5%8B%E8%AF%95%E7%9A%84%E4%B8%BB%E8%A6%81%E6%AD%A5%E9%AA%A4%E5%8F%8A%E5%90%84%E8%87%AA%E5%90%AB%E4%B9%89"><span class="toc-number">9.1.</span> <span class="toc-text">9.1系统测试的主要步骤及各自含义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9E%E5%BD%92%E6%B5%8B%E8%AF%95%EF%BC%9F"><span class="toc-number">9.2.</span> <span class="toc-text">9.2什么是回归测试？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-3%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95%E7%9A%84%E5%90%AB%E4%B9%89%E6%9E%81%E5%85%B6%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">9.3.</span> <span class="toc-text">9.3功能测试的含义极其作用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-4%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%8C%87%E5%AF%BC%E5%8E%9F%E5%88%99%EF%BC%9F"><span class="toc-number">9.4.</span> <span class="toc-text">9.4功能测试的基本指导原则？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-5%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E7%9A%84%E5%90%AB%E4%B9%89%E4%B8%8E%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">9.5.</span> <span class="toc-text">9.5性能测试的含义与作用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-6%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E7%9A%84%E4%B8%BB%E8%A6%81%E5%88%86%E7%B1%BB%EF%BC%9F"><span class="toc-number">9.6.</span> <span class="toc-text">9.6性能测试的主要分类？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-7-%E7%A1%AE%E8%AE%A4%E6%B5%8B%E8%AF%95%E6%A6%82%E5%BF%B5%EF%BC%8C%E7%A1%AE%E8%AE%A4%E6%B5%8B%E8%AF%95%E5%88%86%E7%B1%BB%EF%BC%9F%EF%BC%88%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%92%8C%E5%BC%95%E5%AF%BC%E6%B5%8B%E8%AF%95%EF%BC%89"><span class="toc-number">9.7.</span> <span class="toc-text">9.7.确认测试概念，确认测试分类？（基准测试和引导测试）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-8-%E4%BB%80%E4%B9%88%E6%98%AFalpha%E6%B5%8B%E8%AF%95%EF%BC%9F%CE%B2%E6%B5%8B%E8%AF%95%EF%BC%9F"><span class="toc-number">9.8.</span> <span class="toc-text">9.8.什么是alpha测试？β测试？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-9-%E4%BB%80%E4%B9%88%E6%98%AF%E5%AE%89%E8%A3%85%E6%B5%8B%E8%AF%95%EF%BC%9F"><span class="toc-number">9.9.</span> <span class="toc-text">9.9.什么是安装测试？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-10%E4%BB%80%E4%B9%88%E6%98%AF%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE%EF%BC%9F%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86%EF%BC%9F-%E5%9F%BA%E7%BA%BF%EF%BC%9F"><span class="toc-number">9.10.</span> <span class="toc-text">9.10什么是系统配置？软件配置管理？ 基线？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-11-%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%AF%E9%9D%A0%E6%80%A7%E3%80%81%E5%8F%AF%E7%94%A8%E6%80%A7%E5%92%8C%E5%8F%AF%E7%BB%B4%E6%8A%A4%E6%80%A7%EF%BC%9F"><span class="toc-number">9.11.</span> <span class="toc-text">9.11 什么是可靠性、可用性和可维护性？</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/uncategorized/%E5%9B%BD%E7%A7%91%E5%A4%A7%E8%87%AA%E5%8A%A8%E8%AF%BE%E7%A8%8B%E8%AF%84%E4%BC%B0/" title="国科大自动课程评估">国科大自动课程评估</a><time datetime="2025-12-27T11:39:38.000Z" title="发表于 2025-12-27 19:39:38">2025-12-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/%E7%AC%94%E8%AE%B0/%E3%80%8A%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E9%83%A8%E5%88%86%E7%AC%94%E8%AE%B0/" title="《动手学深度学习》部分笔记">《动手学深度学习》部分笔记</a><time datetime="2025-03-21T01:34:53.000Z" title="发表于 2025-03-21 09:34:53">2025-03-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/%E7%AC%94%E8%AE%B0/%E7%90%86%E8%A7%A3transformer%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84/" title="理解transformer网络结构">理解transformer网络结构</a><time datetime="2025-03-02T07:39:08.000Z" title="发表于 2025-03-02 15:39:08">2025-03-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/%E5%AE%9E%E9%AA%8C/%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0%E9%A2%84%E6%B5%8B%E7%94%9F%E8%BF%98%E8%80%85/" title="集成学习预测生还者">集成学习预测生还者</a><time datetime="2025-02-17T11:37:32.000Z" title="发表于 2025-02-17 19:37:32">2025-02-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/%E5%AE%9E%E9%AA%8C/%E4%B8%89%E7%A7%8D%E5%86%B3%E7%AD%96%E6%A0%91%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB%E6%B1%BD%E8%BD%A6%E5%93%81%E7%89%8C/" title="三种决策树算法分类汽车品牌">三种决策树算法分类汽车品牌</a><time datetime="2025-02-16T15:25:10.000Z" title="发表于 2025-02-16 23:25:10">2025-02-16</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By 姜将</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>